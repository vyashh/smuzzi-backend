from fastapi import APIRouter, Depends, HTTPException, Request, Query, Header
from fastapi.responses import FileResponse, Response, StreamingResponse
from sqlalchemy import func
from sqlalchemy.orm import Session
from database import SessionLocal
from models import Song, Folder, User, Like
from schemas import SongBase, SongListOut
from auth import get_current_user, dev_or_current_user
from services.spotify import enrich_song_from_spotify
from sqlalchemy.exc import IntegrityError

import os, shlex, subprocess, mimetypes, time, uuid, threading, shutil
from typing import Optional, Tuple, Literal

from utils.hls_signing import make_hls_token, verify_hls_token

router = APIRouter()

# ========= CONFIG =========
# Progressive (default) uses the original file — zero disk growth.

# HLS fallback (on-demand, ephemeral)
HLS_ROOT = os.environ.get("HLS_TMP_DIR", "/tmp/smuzzi-hls")   # ephemeral
HLS_PROFILE_VERSION = "ts-live-v1"
SEGMENT_TIME = 4  # seconds
HLS_LIST_SIZE = 12  # rolling window; small for quick start & low disk usage
HLS_DELETE_THRESHOLD = 18  # how many old segments to keep before deletion
HLS_TTL_SECONDS = 20 * 60  # cleanup folders idle > 20 minutes

# Variants: single universal AAC (simplest & fastest)
VARIANTS = [
    ("aac160", "-c:a aac -b:a 160k -ac 2 -ar 44100 -profile:a aac_low", 256000, "mp4a.40.2"),
]

# ========= DB SESSION =========
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# ========= HELPERS =========
def _get_song_and_path(db: Session, song_id: int, user_id: Optional[int]) -> tuple[Song, str]:
    q = db.query(Song).join(Song.folder).filter(Song.id == song_id)
    if user_id is not None:
        q = q.filter(Song.folder.has(user_id=user_id))
    song = q.first()
    if not song:
        raise HTTPException(404, "Song not found")

    folder = db.query(Folder).filter(Folder.id == song.folder_id).first()
    if not folder:
        raise HTTPException(404, "Folder not found")

    file_path = song.filepath or os.path.join(folder.path, song.filename)
    if not os.path.exists(file_path):
        raise HTTPException(404, "File not found")

    return song, file_path

def _mime_from_path(path: str) -> str:
    # Good defaults for common audio
    ext = os.path.splitext(path)[1].lower()
    if ext in [".mp3"]: return "audio/mpeg"
    if ext in [".m4a", ".mp4", ".m4b", ".aac"]: return "audio/mp4"
    if ext in [".flac"]: return "audio/flac"
    if ext in [".wav"]: return "audio/wav"
    if ext in [".ogg", ".oga"]: return "audio/ogg"
    # fallback
    return mimetypes.guess_type(path)[0] or "application/octet-stream"

def _parse_range(range_header: Optional[str], file_size: int) -> Tuple[int, int]:
    # Returns (start, end) inclusive
    if not range_header:
        return 0, file_size - 1
    # Example: "bytes=12345-"
    try:
        units, rng = range_header.split("=")
        if units.strip() != "bytes": raise ValueError
        start_s, end_s = rng.split("-")
        start = int(start_s) if start_s else 0
        end = int(end_s) if end_s else (file_size - 1)
        if start < 0 or end >= file_size or start > end: raise ValueError
        return start, end
    except Exception:
        # Ignore bad Range; serve full
        return 0, file_size - 1

def _iter_file_range(path: str, start: int, end: int, chunk: int = 1024 * 128):
    with open(path, "rb") as f:
        f.seek(start)
        remaining = end - start + 1
        while remaining > 0:
            data = f.read(min(chunk, remaining))
            if not data: break
            remaining -= len(data)
            yield data

def _run_subprocess(cmd: str, cwd: Optional[str] = None) -> subprocess.Popen:
    # Spawn ffmpeg as a background process; return Popen
    return subprocess.Popen(
        shlex.split(cmd),
        cwd=cwd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        bufsize=0,
    )

def _ensure_dir(p: str):
    os.makedirs(p, exist_ok=True)

def _live_dir(song_id: int) -> str:
    return os.path.join(HLS_ROOT, HLS_PROFILE_VERSION, str(song_id))

def _variant_playlist_path(base_dir: str, name: str) -> str:
    return os.path.join(base_dir, f"{name}.m3u8")

def _segment_pattern(name: str) -> str:
    return os.path.join("segments", f"{name}_%05d.ts")  # relative (good for playlist)

def _write_master(path_master: str, variants_meta: list[tuple[str, int, str]]):
    # Minimal master (TS + AAC)
    lines = [
        "#EXTM3U",
        "#EXT-X-VERSION:3",
        "# Master (live TS) generated by API",
    ]
    for name, bw, codecs in variants_meta:
        lines.append(f'#EXT-X-STREAM-INF:BANDWIDTH={bw},CODECS="{codecs}"')
        lines.append(f"{name}.m3u8")
    with open(path_master, "w", encoding="utf-8") as f:
        f.write("\n".join(lines) + "\n")

def _append_token_to_master(master_text: str, token: str) -> str:
    out = []
    for line in master_text.splitlines():
        if line.strip().endswith(".m3u8") and not line.startswith("#"):
            sep = "&" if "?" in line else "?"
            out.append(f"{line}{sep}t={token}")
        else:
            out.append(line)
    return "\n".join(out) + "\n"

def _append_token_to_variant(variant_text: str, token: str) -> str:
    # For TS live playlists, append token to each .ts line
    out = []
    for line in variant_text.splitlines():
        s = line.strip()
        if s and not s.startswith("#") and s.endswith(".ts"):
            sep = "&" if "?" in line else "?"
            out.append(f"{line}{sep}t={token}")
        else:
            out.append(line)
    return "\n".join(out) + "\n"

def _cleanup_stale_live_dirs():
    now = time.time()
    root = os.path.join(HLS_ROOT, HLS_PROFILE_VERSION)
    if not os.path.isdir(root): return
    for song_id in os.listdir(root):
        p = os.path.join(root, song_id)
        try:
            mtime = os.path.getmtime(p)
            if now - mtime > HLS_TTL_SECONDS:
                shutil.rmtree(p, ignore_errors=True)
        except Exception:
            pass

def _touch(path: str):
    try:
        os.utime(path, None)
    except Exception:
        pass

# ========= ENDPOINTS =========
Sort = Literal["created_desc", "created_asc", "title_asc"] 

@router.get("/songs", response_model=SongListOut)
def get_songs(
    limit: int = Query(100, ge=1, le=500),
    cursor: Optional[int] = Query(None, description="id of last seen row"),
    sort: Sort = "created_desc",
    q: Optional[str] = None,
    include_total: bool = False,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user),
):
    base = (
        db.query(Song)
        .join(Song.folder)
        .filter(Folder.user_id == user.id)
    )

    if q:
        like = f"%{q}%"
        base = base.filter(or_(
            Song.title.ilike(like),
            Song.artist.ilike(like),
            Song.album.ilike(like),
        ))

    # ---------- Sorting + keyset pagination ----------
    if sort == "created_desc":
        # Newest → oldest
        ordered = base.order_by(Song.created_at.desc(), Song.id.desc())
        if cursor:
            last = db.query(Song.created_at, Song.id).filter(Song.id == cursor).first()
            if last:
                ordered = ordered.filter(
                    (Song.created_at < last.created_at) |
                    ((Song.created_at == last.created_at) & (Song.id < last.id))
                )

    elif sort == "created_asc":
        # Oldest → newest
        ordered = base.order_by(Song.created_at.asc(), Song.id.asc())
        if cursor:
            last = db.query(Song.created_at, Song.id).filter(Song.id == cursor).first()
            if last:
                ordered = ordered.filter(
                    (Song.created_at > last.created_at) |
                    ((Song.created_at == last.created_at) & (Song.id > last.id))
                )

    else:  # sort == "title_asc"
        ordered = base.order_by(Song.title.asc(), Song.id.asc())
        if cursor:
            # simple id-based paging; fine if titles aren’t heavily duplicated
            ordered = ordered.filter(Song.id > cursor)

    rows = ordered.limit(limit + 1).all()
    items = rows[:limit]
    next_cursor = items[-1].id if len(rows) == limit + 1 else None

    return {
        "items": [SongBase.model_validate(s) for s in items],
        "nextCursor": next_cursor,
        "total": base.count() if include_total else None,
    }

# ------ Progressive (default) ------
@router.get("/stream/{song_id}")
def stream_progressive(
    song_id: int,
    request: Request,
    range: str | None = Header(default=None),
    fallback: Optional[str] = Query(default=None),  # ?fallback=hls triggers HLS path
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user),
):
    """
    Default: Progressive passthrough with byte-range support (instant start, full scrubbing, zero disk).
    Fallback: if ?fallback=hls, return the HLS master (ephemeral, TS+AAC).
    """
    song, file_path = _get_song_and_path(db, song_id, user.id)

    # HLS fallback path
    if (fallback or "").lower() == "hls":
        return _serve_hls_master(song_id, file_path, user.id)

    # Progressive path
    file_size = os.path.getsize(file_path)
    start, end = _parse_range(range, file_size)
    length = end - start + 1
    mime = _mime_from_path(file_path)

    headers = {
        "Accept-Ranges": "bytes",
        "Content-Length": str(length),
        "Content-Type": mime,
        "Cache-Control": "no-cache",
        "Content-Range": f"bytes {start}-{end}/{file_size}",
    }
    return StreamingResponse(
        _iter_file_range(file_path, start, end),
        status_code=206,
        headers=headers,
        media_type=mime,
    )

# ------ HLS (fallback, ephemeral) ------
def _ensure_live_packager(song_id: int, src_path: str):
    """
    Start ffmpeg in the background if not already producing live HLS into /tmp.
    Live-like HLS with rolling window; deletes old segments automatically.
    """
    base_dir = _live_dir(song_id)
    _ensure_dir(base_dir)
    _ensure_dir(os.path.join(base_dir, "segments"))

    # If at least the first playlist exists, assume packager is up
    first_variant = VARIANTS[0][0]
    if os.path.exists(os.path.join(base_dir, f"{first_variant}.m3u8")):
        _touch(base_dir)
        return

    # Build master
    master_path = os.path.join(base_dir, "index.m3u8")
    variants_meta = [(name, bw, codecs) for (name, _, bw, codecs) in VARIANTS]
    _write_master(master_path, variants_meta)

    # Start ffmpeg for each variant
    for (name, audio_args, _, _) in VARIANTS:
        playlist_path = _variant_playlist_path(base_dir, name)
        seg_pattern_rel = _segment_pattern(name)  # relative path for playlist
        cmd = (
            f'ffmpeg -nostdin -hide_banner -y -i {shlex.quote(src_path)} '
            f'{audio_args} '
            f'-vn -sn '
            f'-f hls -hls_time {SEGMENT_TIME} '
            f'-hls_flags independent_segments+delete_segments+append_list '
            f'-hls_list_size {HLS_LIST_SIZE} '
            f'-hls_delete_threshold {HLS_DELETE_THRESHOLD} '
            f'-hls_segment_type mpegts '
            f'-hls_segment_filename {shlex.quote(seg_pattern_rel)} '
            f'{shlex.quote(os.path.basename(playlist_path))}'
        )
        # Spawn in background; cwd=base_dir so playlist uses relative paths we serve under /stream/{id}/...
        _run_subprocess(cmd, cwd=base_dir)

    _touch(base_dir)

def _serve_hls_master(song_id: int, src_path: str, user_id: int):
    _cleanup_stale_live_dirs()
    _ensure_live_packager(song_id, src_path)
    base_dir = _live_dir(song_id)

    master_path = os.path.join(base_dir, "index.m3u8")
    if not os.path.exists(master_path):
        raise HTTPException(500, "HLS master not ready")

    with open(master_path, "r", encoding="utf-8") as f:
        master_text = f.read()

    token = make_hls_token(user_id=user_id, song_id=song_id, ttl_seconds=300)
    master_with_token = _append_token_to_master(master_text, token)

    return Response(
        content=master_with_token,
        media_type="application/x-mpegURL",
        headers={"Cache-Control": "no-store"},
    )

@router.get("/stream/{song_id}/index.m3u8")
def hls_master_alias(
    song_id: int,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user),
):
    # Convenience alias for HLS; creates/returns live master
    _, src_path = _get_song_and_path(db, song_id, user.id)
    return _serve_hls_master(song_id, src_path, user.id)

@router.get("/stream/{song_id}/{variant}.m3u8")
def hls_variant(
    song_id: int,
    variant: str,
    t: str = Query(default=""),
    db: Session = Depends(get_db),
):
    ok, err = verify_hls_token(t, expected_song_id=song_id)
    if not ok:
        raise HTTPException(401, err or "Unauthorized")

    # if packager hasn't started yet, master request will start it; for safety ensure dir exists
    base_dir = _live_dir(song_id)
    valid = {v[0] for v in VARIANTS}
    if variant not in valid:
        raise HTTPException(404, "Unknown variant")

    playlist_path = os.path.join(base_dir, f"{variant}.m3u8")
    if not os.path.exists(playlist_path):
        # not ready yet
        return Response("#EXTM3U\n#EXT-X-VERSION:3\n", media_type="application/x-mpegURL", headers={"Cache-Control":"no-store"})

    with open(playlist_path, "r", encoding="utf-8") as f:
        variant_text = f.read()

    # Append token to each .ts line (playlist is live; we rewrite on every request)
    variant_with_token = _append_token_to_variant(variant_text, t)

    return Response(
        content=variant_with_token,
        media_type="application/x-mpegURL",
        headers={"Cache-Control": "no-store"},
    )

@router.get("/stream/{song_id}/segments/{filename}")
def hls_segment(
    song_id: int,
    filename: str,
    t: str = Query(default=""),
):
    ok, err = verify_hls_token(t, expected_song_id=song_id)
    if not ok:
        raise HTTPException(401, err or "Unauthorized")

    if "/" in filename or "\\" in filename or ".." in filename or not filename.endswith(".ts"):
        raise HTTPException(404, "Not found")

    base_dir = _live_dir(song_id)
    seg_path = os.path.join(base_dir, "segments", filename)
    if not os.path.exists(seg_path):
        raise HTTPException(404, "Segment not found")

    # touch parent dir to postpone cleanup
    _touch(base_dir)

    return FileResponse(
        seg_path,
        media_type="video/MP2T",
        headers={"Cache-Control": "public, max-age=60"},
    )



@router.get("/songs/liked")
def get_liked_songs(
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user),
):
    songs = (
        db.query(Song)
        .join(Like, Like.song_id == Song.id)
        .filter(Like.user_id == user.id)
        .order_by(Like.created_at.desc())
        .all()
    )
    return songs
    
# ========= EXISTING ENDPOINTS =========
@router.get("/songs/{song_id}")
def get_song(song_id: int, db: Session = Depends(get_db), user: User = Depends(get_current_user)):
    song = db.query(Song).join(Song.folder).filter(Song.id == song_id, Song.folder.has(user_id=user.id)).first()
    if not song:
        raise HTTPException(status_code=404, detail="Song not found")
    return song

@router.post("/songs/{song_id}/enrich")
def enrich_one(song_id: int, db: Session = Depends(get_db), user: User = Depends(dev_or_current_user)):
    song = (
        db.query(Song)
        .join(Song.folder)
        .filter(Song.id == song_id, Song.folder.has(user_id=user.id))
        .first()
    )
    if not song:
        raise HTTPException(status_code=404, detail="Song not found")
    ok = enrich_song_from_spotify(db, song, user.id)
    return {"song_id": song_id, "updated": ok}

@router.post("/songs/enrich-missing")
def enrich_missing(db: Session = Depends(get_db), user: User = Depends(dev_or_current_user)):
    songs = (
        db.query(Song)
        .join(Song.folder)
        .filter(Song.folder.has(user_id=user.id), (Song.spotify_id == None))
        .all()
    )
    updated = 0
    for s in songs:
        try:
            if enrich_song_from_spotify(db, s, user.id):
                updated += 1
        except Exception as e:
            print(f"⚠️ enrich error for {s.filename}: {e}")
    return {"count": len(songs), "updated": updated}

@router.post("/songs/{song_id}/like")
def like_song(
    song_id: int,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user),  # <-- model instance, so use user.id
):
    song = db.query(Song).filter(Song.id == song_id).first()
    if not song:
        raise HTTPException(status_code=404, detail="Song not found")

    # idempotent: if it already exists, just say liked=True
    existing = db.query(Like).filter_by(user_id=user.id, song_id=song_id).first()
    if existing:
        return {"liked": True}

    db.add(Like(user_id=user.id, song_id=song_id))
    try:
        db.commit()
    except IntegrityError:
        db.rollback()  # in case of race, treat as already liked
    return {"liked": True}


@router.delete("/songs/{song_id}/like")
def unlike_song(
    song_id: int,
    db: Session = Depends(get_db),
    user: User = Depends(get_current_user),
):
    like = db.query(Like).filter_by(user_id=user.id, song_id=song_id).first()
    if like:
        db.delete(like)
        db.commit()
    return {"liked": False}

